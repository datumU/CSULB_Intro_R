---
title: Introduction to Programming
subtitle: CSULB Intro to R
date: April 13, 2018
#author: Chris Galbraith, Micah Jackson
output: slidy_presentation
smaller: yes
---


## Data Types in R
<!-- hierarchy? -->
+ R has 5 main atomic data types:
    + Logical
    + Integer
    + Numeric
    + Complex
    + Character


## Data Structures in R
1. One-dimensional:
    + Vectors
    + Lists
2. Multi-dimensional:
    + Matrices
    + Data frames

&nbsp;

+ Everything in R is an object
+ Objects can have attributes
    + e.g., names, dimension, length


## Vectors in R:

+ A vector is the most basic structure in R
+ It is one-dimensional; its single dimension is its length
+ A vector of length *n* has *n* cells
+ Each cell can hold a single value, like a numeric or string value
    + In general, vectors can only hold ONE type of data 
  
```{r echo=TRUE}
numVec <- c(2,3,4)      # <- is the assigning operator
numVec
```



## Examples of Vectors

Examples of character, logical, and complex vectors:

```{r echo=TRUE}
charVec <- c("red", "green", "blue")
charVec

logVec <- c(TRUE, FALSE, FALSE, T, F)
logVec

compVec <- c(1 + 0i, 3 + 1i)
compVec
```


## Matrices:

+ A matrix is a special case of a vector
    + Unlike vectors, matrices have a dimension attribute

```{r echo=TRUE}
myMat <- matrix(nrow = 2, ncol = 4)
myMat
attributes(myMat)
```



## Matrices:
```{r echo=TRUE}
myMat <- matrix(1:8, nrow = 2, ncol = 4)
myMat # matrices are filled in column-wise
```



## A matrix is a special case of a vector:

```{r echo=TRUE}
myVec <- 1:8
myVec
dim(myVec) <- c(2,4)
myVec
```

+ Similar to vectors, all elements of a matrix should be of the same data type
    + If not, R automatically coerces



## Other Ways to Create a Matrix:

+ Intuitively, matrices seem to be a combination of vectors that are put next to each other (either column-wise or row-wise).

+ rbind() and cbind() (row bind and column bind) achieve this: 
```{r echo=TRUE}
vec1 <- 1:4
vec2 <- sample(1:100, 4, replace = FALSE)
vec3 <- sample(1:20, 4, replace=TRUE)
colMat <- cbind(vec1, vec2, vec3)
colMat
```



## Other Ways to Create a Matrix:

```{r echo=TRUE}
vec1 <- 1:4
vec2 <- sample(1:100, 4, replace = FALSE)
vec3 <- rnorm(4, mean = 0, sd = 1)
rowMat <- rbind(vec1, vec2, vec3)
rowMat
```



<!-- do we need this slide?

-->

## Factors:

+ A factor is a vector used to specify a discrete classification (categorical values).
+ Factors can be ordered or un-ordered
+ Levels of a factor are better when labeled (self-descriptive)
    + Consider sex as (0, 1) as opposed to labeled ("F", "M")
```{r echo=TRUE}
Sex <- rep(c("Female", "Male"), times = 3)
Sex
SexFac1 <- factor(Sex)
SexFac1
```



## Factors:

```{r echo=TRUE}
levels(SexFac1)
table(SexFac1)
unclass(SexFac1) # returns the factor as integer values
```



## Factors:
```{r echo=TRUE}
SexFac1 # levels are ordered alphabetically - 1st level = BaseLevel
SexFac2 <- factor(Sex, levels = c("Male", "Female"))
SexFac1
SexFac2
```



## Data Type Coercion:

+ In general, vectors CANNOT have mixed types of objects

```{r echo=TRUE, results='hide'}
numCharVec <- c(3.14, "a")
numCharVec                 # What do you expect to be printed? 

numLogVec <- c(pi, T)
numLogVec                   

charLogVec <- c("a", TRUE)
charLogVec 
```

+ The above are examples of implicit coercion 
+ Explicit coercion is also possible


## Data Type Coercion:

+ as(): explicitly coerces objects from one type to another

```{r echo=TRUE}
numVec <- seq(from = 1200, to = 1300, by = 15)
numVec
numToChar <- as(numVec, "character")
numToChar
numToChar==as.character(numVec)
logVec <- c(F, T, F, T, T)
as(logVec, "numeric")
as.numeric(logVec)
```



## Data Type Coercion:

+ Coercion does not always work! Be careful about warnings:

```{r echo=TRUE}
compVec <- c(12+10i, 1+6i, -3-2i)
as(compVec, "numeric")

charVec <- c("2.5", "3", "2.8", "1.5", "zero")
as(charVec, "numeric")
```



## Lists:

+ Think of a list as a vector with the following main differences: 
    + Each element of a list can have its own data structure regardless of other elements
        + vector, matrix, another list
    + This means, each element can be of a different data type and a different length
```{r echo=TRUE}
myVec <- c(10, "R", 10-5i, T)
myVec
```



## Lists:

```{r echo=TRUE}
myList <- list(10, "R", 10-5i, T)
myList
```
+ Elements of a list are shown with [[]]
+ Elements of a vector are shown with []



## Data Frames:

+ A data frame is a special list where all objects have equal length
+ A data frame looks very similar to a matrix; however, different columns in a data frame can be different data types
```{r echo=TRUE}
studentID <- paste("S#", sample(c(6473:7392), 10), sep = "")
score <- sample(c(0:100), 10)
sex <- sample(c("female", "male"), 10, replace = TRUE)
data <- data.frame(studentID = studentID, score = score, sex = sex)
head(data)
```


## Special Values:

There are some special values in R:

  + Use L to refer to an integer value, e.g., 1L
  + R knows infinity: Inf, -Inf
  + NaN: refers to "Not a number"
  
```{r echo=TRUE}
intVec <- c(1L, 2L, 3L, 4L) 
intVec

a <- Inf; b <- 0
rslt <- c(b/a, a/a)
rslt
```


## Missing Values:

+ There are two kinds of missing values in R:
    + NaN: stands for "Not a Number" and is a missing value produced by numerical computation.
    + NA: stands for "Not Available" and is used when a value is missing

+ NaN is also considered as NA (the reverse is NOT true)
```{r echo=TRUE}
a <- c(1,2)
a[3]

b <- 0/0
b
```


## Subsetting:

+ Sometimes, we want to take a subset of a vector, matrix, list, or data frame
+ Consider three main operators to take a subset of an object
    + [ ] single brackets return an object of the same class of the original object (typically vectors, matrices)
    + [[ ]] double brackets are used to subset lists and dataframes by an (numeric) index
    + $ used to subset lists and dataframes by their **name** attributes
+ [ ] allows us to select more than one element 
+ [[ ]] and $ allow us to select only one (though this *one* may be a structure with multiple elements) 
      
    
   



## Subsetting Examples:

```{r echo=TRUE}
myVec <- 1:10
myVec[3]

myList <- list(obj1 = "a", obj2 = 10, obj3 = T, obj4 = 10-5i)
myList[[3]]
myList$obj4
```



## Subsetting with [ ]:

+ By using single brackets, we can choose more than one element of an object
```{r echo=TRUE}
x <- seq(from=0, to=100, by=10) 
x
x[1:3]           # select the first, second, and third elements
x[c(2,4,6)]      # select the second, fourth, and six elements
```






## Subsetting with [ ]: Index Vectors

+ Another way to select more than one element from an object is by using index vectors
    + An index vector is a vector of indices that is used to select a subset of another vector (or matrix)
  
```{r echo=TRUE}
x <- seq(from=0, to=100,by=10) 
x
IndVec <- c(1, 2, 3, 4, 5)       # index vector to select the first 5 elements 
x[IndVec]
```



## Index Vectors:

+ There are four types of index vectors:
    1. Logical index vector
    2. Vector of positive integers
    3. Vector of negative integers
    4. Vector of character strings



## Example:

+ Suppose we have grades of ten students

```{r echo=TRUE}
grades <- sample(0:100, 10)
attributes(grades)
names(grades) <- letters[1:10]
attributes(grades)
grades
```

+ We will explore the different ways to subset this vector using index vectors






## 1. Index Vector of Positive Integers
+ A vector of positive integers corresponding to the elements you want to subset
+ All of the values in this type of index vector must lie in 1:(length(x)).
```{r echo=TRUE}
posIndVec <- 4:7
posIndVec

grades[posIndVec]
```




## 2. Index Vector of Negative Integers
+  A vector of negative integers indicates the values to be **excluded** from the vector
```{r echo=TRUE}
negIndVec <- -1:-5
negIndVec

grades[negIndVec]
```




## 3. Vector of Character Strings
+ If a vector has a name attribute, we can take a subset of the vector by calling the names of the elements
```{r echo=TRUE}
chIndVec <- c("a")
chIndVec

grades[chIndVec]
```


## 4. Logical Index Vector

+ A vector of TRUE/FALSE values that should be the same length as the vector from which we are subsetting. 
    + Values corresponding to TRUE in the index vector are selected

```{r echo=TRUE}
logIndVec <- rep(c(T, F), each = 5)
logIndVec

grades[logIndVec]
```



## 4. Logical Index Vector

+ Logical index vectors can also be generated by using conditional statements
    + Using ==, !=, <, >, ...

```{r echo=TRUE}
logIndVec <- grades > 60
logIndVec

grades[logIndVec]
grades[grades < 40]
```




## Subsetting Matrices: 
+ We also use the single square brackets to subset matrices
    + In the square brackets, the first position refers to the row(s) and the second position refers to the column(s)
```{r echo=TRUE}
myMat <- matrix(1:8, ncol = 4)
myMat
```

+ Let's go over the various ways to subset this matrix




## Subsetting Matrices: 

```{r echo=TRUE}
myMat[1,1]            # retrieve the element in the first row, first column
myMat[2,]             # retrieve the second row
myMat[,-3]             # remove the third column
```  



## Subsetting Matrices:

+ By default, when the retrieved elements of a matrix look like a vector, R drops their dimension attribute. We can turn this feature off by setting drop = FALSE

```{r echo=TRUE}
myMat[1,1]
myMat[1,1, drop = FALSE]

myMat[2,, drop = FALSE]
``` 



## Subsetting Lists:
```{r echo=TRUE}
myList <- list(ID = paste("ID", sample(c(100:199), 3), sep = ""), Age = sample(c(18:99), 3), Sex = sample(c("M", "F"), 3, replace = TRUE))
myList
myList[1] # subset is still a list
``` 



## Subsetting Lists:
```{r echo=TRUE}
myList[1:2] # return the first two objects; subset is still a list
myList[[1]] # return the 1st object; subset is a character vector
myList$ID # alternative to [[]]
``` 



## Subsetting Lists:
```{r echo=TRUE}
myList[[1]][2] # return the 2nd element of the 1st object
myList$ID[2]
myList[[c(1,2)]]
``` 



## Subsetting Data Frames:
```{r echo=TRUE}
str(data)
``` 

## Subsetting Data Frames:

```{r echo=TRUE}
data[1:8,]
``` 


## Subsetting Data Frames: 

```{r echo=TRUE}
head(data$sex)
head(data[,c("studentID", "score")])
```


<!-- TRANSITION BITCH -->


## Control Structures:

+ A control structure is a block of programming that analyzes variables and chooses a direction in which to go based on given parameters
+ Control structures in R include:
    + **for loops**
    + **if/else statements**
    + while loops 
    + repeat
    + break 
    + next
    + return
  

## for loops:

+ Suppose we want to write "The year is [year]" where year is equal to 2014, 2015, and 2016. 
+ One way to do so is like this:

```{r echo = T}
print(paste("The year is", 2016))
print(paste("The year is", 2017))
print(paste("The year is", 2018))
```


## for loops:

+ Or, we can use a for loop: 

```{r echo = T}
for(i in 2016:2018){
  print(paste("The year is", i))
}
```

## for loops:

+ Suppose we have a numeric vector and we want to square each element
```{r echo = TRUE}
vec <- seq(2, 20, by = 2)
```
+ First, create a new vector of the same length as ```vec```
```{r echo = TRUE}
newvec <- vector("numeric", length = length(vec)) # equivalent: numeric(length(vec))
```
+ Then, write the for loop
```{r echo = TRUE}
for(i in 1:length(vec)){
  newvec[i] <- vec[i]^2
}
newvec

# advanced: vec^2
```

## if/else statements:

+ if/else statements are used to write conditional statements

```{r echo = T}
x <- 7
if (x < 10){
  print("x is less than 10")
}else{
  print("x is greater than 10")
}
```

## Combining for loops and if/else statements:
+ Suppose we have the ages of 10 individuals, and we want to categorize each age as young, middle-aged, or old
+ Using a for loop, we can iterate through each age and then use if/else statements to classify each age

## for loops and if/else statements:
```{r echo = T}
age <- sample(1:100, 10)
ageCat <- rep(NA, length(age))
for (i in 1:length(age)) {
    if (age[i] <= 35){
       ageCat[i] <- "Young"
      }else if (age[i] <= 55){
        ageCat[i] <- "Middle-Aged"
      }else{
         ageCat[i] <- "Old"
      } 
}
age.df <- data.frame(age = age, ageCat = ageCat)
age.df[1:3,]
```

<!-- need to put transition slide or something -->

## Functions
+ **What:** 
    + A chunk/block of code that encapsulates a set of instructions (including other functions!).

+ **Why:** <!-- Wording ok? -->
    + Readability: Using functions makes it easier to read your code. This allows us to more quickly debug and makes it easier to make updates to our code later.
    + Reusability: Instead of rewriting a set of instructions multiple times to complete similar tasks, you can just make a call to one function.
    + Abstraction/Generalization: Functions should allow you to easily use different inputs of varying size, amount, type, etc.
    + Automation: Functions allow you to automate a task instead of manually typing out instructions
    

## How to write functions
+ Steps to writing a function
    1. Understand the purpose of the function. What do you want it to do?
    2. Define input (parameters, arguments).
    3. Determine the algorithm and output.
    4. Define data needed inside of the function (extra variables, storage, etc).
    

<!-- need example here and prob quick hand written exercise where they write their own function. write sandwich into a function? -->


<!-- Part 7 -->
## Guided Exercise
+ What do we want our function to do?
    + Find the tallest height from a collection of heights
+ Define input.
    + "collection of heights"
    + vector of heights
    + in feet? cm? inches? miles?
    + I'm 0.00111 miles tall.
    
## Exercise Cont'd
+ Determine algorithm and output.
    + output is height of tallest person (i.e. the maximum value)

**Initialize** $tallest$ = $height_1$  
**For** each $element$ in $H$, **do**  
&nbsp;&nbsp;&nbsp;&nbsp;**If** $element > tallest$, **then**  
&nbsp;&nbsp;&nbsp;&nbsp;$tallest = element$  
end **for**  
**return** $tallest$  

```{r, evaluate=FALSE }
myHeights <- c(63, 58, 72, 65)

findTallest <- function(H){
  tallest <- H[1]
  for(height in H){
    if(height > tallest){tallest <- i}
  }
  return(tallest)
}
```

<!-- prompt them to modify the code to find the oldest person, shortest person, handle NA values -->

<!-- Parts 8,9 -->
